# Применение `OWL2` для системы типов.

## Введение

`OWL2` основан на дескрипционной логике, описывает знания об объектах и классах с помощью выражений, составленных из предикатов и атомов. Совокупность объектов составляет `домен`, то есть некую предметную область.

Очень [крутой и мощный язык](https://www.w3.org/TR/2012/PER-owl2-quick-reference-20121018/). Нам он нужен в качестве базы для описания пользовательских типов объектов. Интересен, в частности, т.н. "[манчестерский синтакс](https://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121018/)", то есть форма записи OWL2-выражений в удобной для чтения форме.

## Технологии

Манчестерский синтаксис похож на синтаксис `ot`, то есть не возникнет проблемы слегка преобразовать манчестерский синтаксис к виду `ot` синтаксиса без потери семантических свойств. Для этого в парсер Own/L был введён специальный режим разбора языка `ot`, который предполагает отсуствие предопределённых идентификаторов и чувствительность к знаку `;`. После разбора `ot` должен произойти разбор полученного древовидного описания в структуру, более подходящую для описания типа с помощью `OWL2`.

## Возможности

`OWL2` предоставляет набор предопределённых выражений для описания свойств объекта или данных.
Не все из них имеют смысл для описания типа данных в языке `own/l`.

### Простейший класс
Надо рассмотреть на конкретной задаче определения типов.
Например, тип `BYTE` обозначает машинный знаковый байт из 8 бит, следовательно, его значение будет целочисленным, будет ограничено значениями от -128 до 127, будет совместимо с другими целочисленными типами в арифметических операциях. Допустим, мы не хотим вводить машинозависимый тип `BYTE` в язык, но мы можем описать его в стороннем модуле.

Итак, тип `BYTE` целочисленный. То есть это подтип типа `INTEGER`, который обозначает любое целое число (представим, что оно ничем не ограничено, а ещё оно встроено в язык OWL2 и определено в корневой онтологии, поэтому нам не надо его определять).

Далее, тип и класс это одно и то же. Индивид и объект (значение переменной, константы, значение выражения) это одно и то же.

В OWL2 класс описывает набор общих свойств для всех индивидов данного класса. Байт это класс.

    Class: BYTE

Теперь класс `BYTE` служит базой для выстраивания таблицы свойств и ограничений. У будущих индивидов класса `BYTE` будет существовать конкретное значение целочисленного типа. А это значит, что у класса должно быть свойство `hasIntValue`. Вводим это свойство мы сами, определяем что это свойство принадлежит домену "типы данных", над которым мы тут работаем. И значение этого свойства лежит в диапазоне целых чисел.

    DataProperty: hasIntValue Domain: TYPE Range: INTEGER

 Технически, мы должны определить это свойство на "уровень" выше, чем наш класс, а так же должны описать класс `TYPE` как тип данных вообще.

Добавим свойство `hasIntValue` нашему классу. У этого типа может быть только одно значение, укажем и этот факт.

    Class: BYTE SubClassOf: hasIntValue exactly 1

Здесь мы понимаем, что класс `BYTE` это подкласс всех классов с одним значением целочисленного типа из домена `TYPE`.
Свойство `hasIntValue` является функциональным, то есть оно имеет значение для любого класса, к которому применено.

Далее, нам необходимо ограничить диапазон значений типа `BYTE`. Для ограничения диапазона значений применяется ключевое слово `some` и затем выражение диапазона или набора.

    Class: BYTE SubClassOf: hasIntValue exactly 1 and hasIntValue some INTEGER[>=-128, <=127].

класс `BYTE` это подкласс всех классов с одним значением лежащим в диапазоне [-128, 127] целочисленного типа из домена `TYPE`. Вроде всё верно.

## OWL2ot

Для унификации используемых конструкций в языке `own/l` нужно представить описание типа `BYTE` в виде иерархического дерева классов языка `ot`.

    TYPE :: SubClassOf: INTEGER;
      SubClassOf: hasIntValue exactly 1
              and hasIntValue some INTEGER: -128 127;;
    ; -> BYTE

## Ссылки

* https://www.w3.org/TR/owl2-manchester-syntax/
